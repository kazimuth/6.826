> Why does it not always work to define an abstraction function from code state to spec state in order to do a simulation proof that the code implements the spec? Assuming that the spec doesnâ€™t make any premature decisions, what are two ways to extend the abstraction function idea so that it will always work?

it doesn't always work because one code state can map to multiple spec states. this can be resolved by either adding "history variables" to the code, which are elided at runtime but keep enough information to maintain a many-to-one mapping; or you can just directly define a many-to-many spec relation. these are equivalent; if you examine all possible settings of the history variables and then collapse the function to a relation by identifying states with the history variables removed, you get a spec relation.
